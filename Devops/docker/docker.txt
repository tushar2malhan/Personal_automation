|                                   Overview  of   docker

base image  > instructions on container > final image 
[ we give the docker final image as deliverable to ur colleague to test the code ]



#                         Dockerfile Instructions


FROM  ubuntu                                  # [ as base image for the application  ]  #  FROM ubuntu:latest, # FROM scratch = create a new image from scratch

LABEL tusharmalhan                            # author name 

WORKDIR /app                                  # when container is created, create a directory
|                                             #  "app" and will cd into it

COPY . /app                                   # copy from my local dir to the container dir "app"   # copy  source destination

ADD                                           # As COPY, but also able to handle remote URLs and unpack compressed files.

RUN apt-get update && apt-get install -y      # During the build, run these Instructions   # typically for install packages, db, install requirements.txt

EXPOSE 8080                                   # expose port 8080 to the host = localhost:8080

CMD ["python", "app.py"]                      # AFTER the build , run the app.py file # run the application, process, command 

ENV                                           # stores environment variables in the container as well as build  |eg (db.py)     ->    DATABASE_URL = os.get.enviorn(DATABASE_URL) 
|                                             #                                                                    (Dockerfile) ->    ENV DATABASE_URL = postgres+psycopg2://aws_link      or  hostname:port/dbname

ENTRYPOINT                                    # entrypoint overrides the CMD commands first and then run CMD commands 
|                                             # Entrypoint's Command that will always be executed when the container starts. If not specified, the default is /bin/sh -c
|                                             # Used for initialization the application just before launching the container or the script in CMD command 


# --> if any one of the steps fail, container will stop ! and docker will not build the image

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' 

#                     COMMANDS
- docker ps                                               # list all containers
- docker ps -a                                            # list all containers with details
- docker images                                           # list all images
- docker build -t  image_name .                           # build the image
- docker run -d -p 8080:8080 image_name                   # run the image and expose port 8080 to the host            # -d = detached mode, -p = port mapping

- docker volume create vol_name                           # create a volume
- docker run -d -p 8080:8080 -v vol_name:/app image_name  # map volume with container 



- run is executed   = during the build of the image 
- cmd gets executed = when the container is ready to run



# Difference between run , cmd and entrypoint ?
RUN is used DURING the build process 
->      CMD & ENTRYPOINT executes  AFTER the container is created and when app is ready to launch 

ENTRYPOINT - here is used to override the CMD command
|          - for passwords and credentials 
|          - and initializes the app before launching the container or python script in CMD command
|          - so ENTRYPOINT runs first and then CMD command

Eg      just before launching Mysql container ,
        we can run a script to initialize the database 
        like setup admin pass, grant privileges etc.
        and then we can run the Mysql container using CMD command -> mysqld

->      CMD VS ENTRYPOINT

 Q what is default command when we run the container ?
  =  docker run -it image_name ['default_command'] eg -> docker run -it ubuntu:latest bash
  # where bash is the default command
  # can be ['echo','hi'] -> which will print "hi" when container runs 

  #  in Dockerfile
  - CMD ["echo", "hi"]
  * docker run -it my_image_1:1.0 echo hi  == echo hi is the default command for CMD , default is ['/bin/bash']

  - ENTRYPOINT ["echo", "hi"]               # default CMD command = ['/bin/bash']
  * docker run -it my_image_1:1.0          == by default , in addition to CMD , ENTRYPOINT cmd also runs 

  #        This will run the container with msg hi as output 

== ENTRYPOINT always runs first and then CMD command



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
|                 Running PostgreSQL on docker 

The first option uses Docker Compose ->
- a tool for managing multi-container Docker applications.
  You can use Docker Compose to configure the Postgres 
  as a service running inside of a container. 
  In that case, you create a yaml file with all the specifications.
  
  [ The yaml configuration file outlines there is a postgres service, 
    built on the latest postgres image. You can decide on the 
    newest Postgres version or specify the version number you want to use.
    
    Finally, you need to define the ports on which the container communicates. 
    5432 is the default port number for PostgreSQL.

    Save and exit the file.

    Now that you have the yaml configuration file, you can 
    start the postgres service and run the container. 
    Use the docker-compose up command with the -d option 
    to put it into detach mode 
    (allowing you to continue to run commands from the current shell) ]


Alternatively, you can use a single Docker command 
 with all the necessary information 
 for deploying a new PostgreSQL container.

-> docker run --name [container_name] -e POSTGRES_PASSWORD=[your_password] -d postgres

 - Connect to Postgres in Docker Container
  To enter a Postgres container, you need to 
  execute using the container name and enable psql, 
  the command-line interface for Postgres.
-> docker exec -it [container_name] psql -U [postgres_user]



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
#                      Docker Bridge Network

it is a network that bridges the host and the container

|              

When you create a new container,
 you can specify one or more --network flags. 
This example connects a Nginx container 
to the my-net network. It also publishes 
port 80 in the container to port 8080 on
 the Docker host, so external clients can 
access that port. Any other container connected 
to the my-net network has access to all ports 
on the my-nginx container, and vice versa.

 docker create --name my-nginx \
  --network my-net \
  --publish 8080:80 \
  nginx:latest

To connect a running container to an existing
 user-defined bridge, use the docker network 
connect command. The following command connects 
an already-running my-nginx container to an
 already-existing my-net network:

 docker network connect my-net my-nginx

# It helps to create a bridge network in the host machine
# and then connect the container to that network

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
|               Queries 

# Difference between copy and add ?
COPY -  just copies files from the host to the container
ADD - also allows to extract .zip files  and add it to the container


Q If container does not run or executed, make sure you run container name with tag name !
= docker run -it my_image_1:1.0 bash            ==   -it to go interactive mode , bash to use CLI 



Q wanna add whl file to ur image ?
= Use ADD or COPY , copy from local dir to destination dir in container
  - ADD  fortclient_tcube_selenium.py PyAudio-0.2.11-cp310-cp310-win_amd64.whl /


Q Copy whole Protected folder to container directory ?
= - COPY Protected  /Protected
  - COPY python_samples  /python_samples
  - ADD ./app /app      ->  
  Copies whole  directory  from your local dir (source ) to the container dir = destination


Data volume containers exist only to store data for the purpose of data persistence.
  - used to store application data , exists in parallel to application container 
  - storing things like log files, customizations, configurations inorder to prevent the loss of the app data 
  - Data volume containers are never in a running state

Q How and which base image to take ?
  Whatever application we need to build like web server APACHE , Mysql , FastAPi (python),
  we need to take the base image of that application.

  - Smaller in size (build, pull, push is fast)
  - Take little space as the compared large image
  - Consume less MEMORY by the OS itself as compared to CentOS
  - Alpine is considered secure and fast
  - Alpine is an offical image for docker registry

  - Either use the official image or use the one you have downloaded from Docker Hub
  - OR Create image from scratch  >  FROM scratch  > in Dockerfile



Q Docker Daemon

- Docker daemon is a persistent background process that manages the containers on
- a single host. 
- It is a self- sufficient runtime that manages Docker objects 
- such as images, containers, network, and storage. 
- when u create and build the Dockerfile, docker daemon is the one
- which create the container 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
|                        Best Practices 

#       1. Use the latest version of the base image (latest version of the image)

#       2. Build the image from within the build context (shell script)

mkdir myproject && cd myproject
echo "hello" > hello
echo -e "FROM busybox\nCOPY /hello /\nRUN cat /hello" > Dockerfile
docker build -t helloapp:v1 .


#         3. In Dockerfile   use single RUN command to execute the application

  RUN apt-get update && apt-get install -y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion \
  && rm -rf /var/lib/apt/lists/*


#         4. Use Single LABEL 
#         Set multiple labels on one line

LABEL com.example.version="0.0.1-beta" com.example.release-date="2015-02-12"